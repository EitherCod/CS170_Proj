import networkx as nx
from networkx.algorithms import approximation
from parse import read_input_file, write_output_file, read_output_file
from utils import is_valid_network, average_pairwise_distance, average_pairwise_distance_fast
import sys
import os
import time


def solve(G):
    """
    Args:
        G: networkx.Graph

    Returns:
        T: networkx.Graph
    """

    # TODO: your code here!
    # if no edges, return G
    if not nx.number_of_edges(G):
        return G

    


        # Method 1:

    # Generate an mst
    # idea to try: test out mst's generated by
    # running prim's on every possible source node
    # and choose the best one
    min_spanning_tree = nx.minimum_spanning_tree(G, 'weight')
    pruned_mst = remove_leaves(min_spanning_tree)


    # Method 2: dominating set
    # weight each node with the average distance
    # to every other node
    for v in G.nodes:
        G.nodes[v]['w'] = nx.algorithms.shortest_paths.generic.average_shortest_path_length(G, weight='weight')
        # maybe replace this with a less intensive heuristic:
        # for edge in G.adj[i]:
        # sum up the edge weights
        # nx documentation here: https://networkx.github.io/documentation/stable/tutorial.html

    dom_set = list(nx.algorithms.approximation.dominating_set.min_weighted_dominating_set(G, weight='w'))
    shortest_paths = nx.algorithms.shortest_paths.generic.shortest_path(G, weight='weight')
    X = nx.Graph()
    for i in range(len(dom_set)):
        v = dom_set[i]
        #print("i: " + str(i) + ", dom_set[i]: " + str(v))
        for j in range(i + 1, len(dom_set)):
            u = dom_set[j]
            #print("j: " + str(j) + ", dom_set[j]: " + str(u))
            path = shortest_paths[v][u]
            #print(path)
            paths = path_to_list(path, G, X)
            #print(paths)
            if (paths):
                X.add_weighted_edges_from(paths)
    dom_mst = nx.minimum_spanning_tree(X, 'weight')

    if not dom_mst:
        print("Dom mst is null")
        return pruned_mst
    cost1 = average_pairwise_distance_fast(dom_mst)
    print("Dominating Set: " + str(cost1))
    cost2 = average_pairwise_distance_fast(pruned_mst)
    print("    Pruned MST: " + str(cost2))
    if (cost1 == cost2):
        print("Equal cost!")
        return dom_mst
    if (cost1 < cost2):
        print("Dominating Set is better")
        return dom_mst
    else:
        print("Pruned MST is better")
        return pruned_mst


def path_to_list(path, G, X):
    lis = []
    for i in range(len(path) - 1):
        v = path[i]
        u = path[i+1]
        p = 0
        try:
            p = X.edges[v, u]
        except:
            w = G.edges[v, u]['weight']
            e = (v, u, w)
            #print(e)
            lis.append(e)
    return lis






# Handles removing appropriate leaves from
# the given minimum spanning tree.
# This became a function in order to make
# testing of different leaf-list
# sortings and mst strategies easier
def remove_leaves(min_tree):
    # Step 1: Create list of leaves
    leaves = []
    for v in min_tree.nodes:
        if min_tree.degree[v] == 1:
            leaves.append(v)

    # Step 2: Cost-compare method:
    # Iterate through leaves and see if removing them will 
    # lower cost (this is a fairly expensive computation).
    # Continue looping through remaining leaves until
    # no more leaves are removed
    #
    removed = 1
    while removed > 0:
        min_tree, leaves, removed = prune_leaves(leaves, min_tree)

    return min_tree




# This method removes leaves from a given min_tree
# if doing do decreases the cost (average pairwise
# distance)
def prune_leaves(leaves, min_tree):
    removed = 0
    kept_leaves = []
    for leaf in leaves:
        if (leaf):
            e = list(min_tree.edges(leaf, data='weight'))[0]
            #print("leaf: " + str(leaf))
            #print("leaf edge: " + str(e))
            cost = average_pairwise_distance_fast(min_tree)
            min_tree.remove_node(leaf)
            new_cost = average_pairwise_distance_fast(min_tree)
            if (new_cost > cost):
                min_tree.add_node(leaf)
                min_tree.add_edge(e[0], e[1], weight=e[2])
                #print("Leaf kept")
                kept_leaves.append(leaf)
            else:
                removed += 1
    if (removed):
        print("We removed " + str(removed) + " leaves in this iter")
    return min_tree, kept_leaves, removed



# Prints a list of all leaves in a given
# leaf-list
def print_leaves(leaves, min_tree):
    lis = []
    for leaf in leaves:
        lis.append(list(min_tree.edges(leaf, data='weight'))[0])
    print("Leaves: ")
    print(lis)





# To run: python3 solver.py inputs

if __name__ == '__main__':
     assert len(sys.argv) == 2
     p = sys.argv[1]
     for path in os.listdir(p):
        print()
        print("Trying file: " + path)
        G = read_input_file(p + '/' + path)
        T = solve(G)
        assert is_valid_network(G, T)
        print("Average  pairwise distance: {}".format(average_pairwise_distance(T)))
        out = 'out/' + path[:len(path) - 3]
        out = out + '.out'
        # print('output path: ' + out)
        write_output_file(T, out)
        read_output_file(out, G)












    # Avg-weight/Cost-Checking Hybird Method:
    # this is outperformed by full cost-checking method,
    # an I'm not sure why. rip. this is what it does:
    # First, Use avg to cull obvious large leaf edges:
    # Remove edges with weights that are 
    # greater than or equal to the average, 
    # and recalculate the average.
    # Then use cost-checking for the rest

#    sum = 0
#    for (u, v, wt) in G.edges.data('weight'):
#        sum += wt
#    avg = sum / nx.number_of_edges(G)
#
#    phase = 0
#    for leaf in leaves:
#        if (leaf):
#            if phase == 0:
#                #print("leaf: " + str(list(min_tree.edges(leaf, data='weight'))[0]))
#                edge_weight = list(min_tree.edges(leaf, data='weight'))[0][2]
#                if edge_weight >= avg:
#                    #print("Leaf removed!")
#                    min_tree.remove_node(leaf)
#                    num_edges = nx.number_of_edges(min_tree)
#                    if (num_edges):
#                        avg = (((num_edges + 1) * avg) - edge_weight) / num_edges
#                    else:
#                        avg = 0
#                else:
#                    phase = 1
#                    print("phase 0 removed " + str(removed) + " leaves")
#            else:
#                e = list(min_tree.edges(leaf, data='weight'))[0]
#                #print("leaf: " + str(leaf))
#                #print("leaf edge: " + str(e))
#                cost = average_pairwise_distance_fast(min_tree)
#                min_tree.remove_node(leaf)
#                new_cost = average_pairwise_distance_fast(min_tree)
#                if (new_cost > cost):
#                    min_tree.add_node(leaf)
#                    min_tree.add_edge(e[0], e[1], weight=e[2])